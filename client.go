package main

import (
	"flag"
	"fmt"
	"net"
	"os"
	"sync"
	"time"
)

var ip = flag.String("ip", "127.0.0.1", "The ip address of the host")
var port = flag.Int("port", 1337, "The port of the host")
var number = flag.Int("number", 1, "The number of parallel connections")
var id = 0
var mutex sync.Mutex
var handlers = make(map[int]float64)

func penetrateTCP() {
	handlerId := id
	id++

	mutex.Lock()
	handlers[handlerId] = 0
	mutex.Unlock()

	conn, err := net.Dial("tcp", fmt.Sprintf("%s:%d", *ip, *port))
	if err != nil {
		fmt.Printf("Connection refused at %d\n", handlerId)
		os.Exit(1)
	}

	// Init buffer with crap
	buf := make([]byte, 4096)
	for i := 0; i < len(buf); i++ {
		buf[i%len(buf)] = byte(i)
	}

	// Push unlimited
	timeStamp := time.Now()
	written := 0
	for {
		// Write next buffer
		n, err := conn.Write(buf)
		if err != nil {
			fmt.Printf("Write failed at %d\n", handlerId)
			os.Exit(1)
		}

		// Update vals
		written += n
		now := time.Now()
		duration := now.Sub(timeStamp).Seconds()

		// Check if time has passed
		if duration > 1.0 {

			// Compute the throughput
			mbPerSec := float64(written) / duration / 1024.0 / 1024.0

			// Update map
			mutex.Lock()
			handlers[handlerId] = mbPerSec
			mutex.Unlock()

			// Reset vals
			timeStamp = now
			written = 0
		}
	}
}

func main() {
	// Start all handlers
	flag.Parse()
	for i := 0; i < *number; i++ {
		go penetrateTCP()
	}
	fmt.Println("Started all handlers...")

	// Watchout for all rates
	for {
		time.Sleep(time.Second)

		// Create copy of statistics
		mutex.Lock()
		rates := make(map[int]float64)
		for k, v := range handlers {
			rates[k] = v
		}
		mutex.Unlock()

		for k, v := range rates {
			fmt.Printf("%d runs at %f mb/sec\n", k, v)
		}
	}
}
