package main

import (
	"flag"
	"fmt"
	"math"
	"net"
	"os"
	"sync"
	"time"
)

var ip = flag.String("ip", "127.0.0.1", "The ip address of the host")
var port = flag.Int("port", 1337, "The port of the host")
var number = flag.Int("number", 1, "The number of parallel connections")
var mb = flag.Int("mb", 1, "The payload in mega bytes")
var id = 0
var mutex sync.Mutex
var mutex2 sync.Mutex
var totalWritten = make(map[int]float64)
var longTermHandlers = make(map[int]float64)
var handlers = make(map[int]float64)

var sig = make(chan bool)
var sig2 = make(chan bool)
var sig3 = make(chan bool)

func penetrateTCP() {
	mutex2.Lock()
	handlerId := id
	id++
	mutex2.Unlock()

	payload := (*mb * 1024 * 1024) / (*number)

	mutex.Lock()
	totalWritten[handlerId] = 0
	handlers[handlerId] = 0
	longTermHandlers[handlerId] = 0
	mutex.Unlock()

	conn, err := net.Dial("tcp", fmt.Sprintf("%s:%d", *ip, *port))
	if err != nil {
		fmt.Printf("Connection refused at %d\n", handlerId)
		os.Exit(1)
	}
	defer conn.Close()

	// Init buffer with crap
	buf := make([]byte, 1024)
	for i := 0; i < len(buf); i++ {
		buf[i%len(buf)] = byte(i)
	}

	// Push unlimited
	initTimeStamp := time.Now()
	timeStamp := initTimeStamp
	written := 0
	longTermWritten := 0

	sig <- true
	<-sig2

	start := time.Now()

	for longTermWritten < payload {

		rem := int(math.Min(float64(payload-longTermWritten), float64(len(buf))))

		// Write next buffer
		n, err := conn.Write(buf[:rem])
		if err != nil {
			fmt.Printf("Write failed at %d\n", handlerId)
			os.Exit(1)
		}

		// Update vals
		written += n
		longTermWritten += n
		now := time.Now()
		duration := now.Sub(timeStamp).Seconds()
		longTermDuration := now.Sub(initTimeStamp).Seconds()

		mutex.Lock()
		totalWritten[handlerId] = float64(longTermWritten) / 1024.0 / 1024.0
		mutex.Unlock()

		// Check if time has passed
		if duration > 1.0 {

			// Compute the throughput
			mbPerSec := float64(written) / duration / 1024.0 / 1024.0
			longTermMbPerSec := float64(longTermWritten) / longTermDuration / 1024.0 / 1024.0

			// Update map
			mutex.Lock()
			// Update long term
			handlers[handlerId] = mbPerSec
			longTermHandlers[handlerId] = longTermMbPerSec
			mutex.Unlock()

			// Reset vals
			timeStamp = now
			written = 0
		}
	}

	fmt.Printf("%d completed in %f seconds\n", handlerId, time.Now().Sub(start).Seconds())

	sig3 <- true
}

func main() {
	// Start all handlers
	flag.Parse()
	for i := 0; i < *number; i++ {
		go penetrateTCP()
	}
	fmt.Println("Started all handlers...")

	for i := 0; i < *number; i++ {
		<-sig
	}

	close(sig2)
	/*
		// Watchout for all rates
		for {

			time.Sleep(time.Second * 10)

			// Create copy of statistics
			mutex.Lock()
			rates := make(map[int]float64)
			for k, v := range totalWritten {
				rates[k] = v
			}
			mutex.Unlock()

			sum := 0.0
			for i := 0; i < len(rates); i++ {
				_, v := i, rates[i]
				sum += v
				//fmt.Printf("%d has written %f mb\n", k, v)
			}
			average := sum / float64(len(rates))

			for i := 0; i < len(rates); i++ {
				k, v := i, rates[i]
				v = average - v
				fmt.Printf("%d ranges about %f mb\n", k, v)
			}

			fmt.Printf("Average: %f mb\n", average)
			fmt.Printf("Sum: %f mb\n", sum)
			fmt.Println()
		}*/

	start := time.Now()
	for i := 0; i < *number; i++ {
		<-sig3
	}
	fmt.Printf("All completed in %f seconds\n", time.Now().Sub(start).Seconds())
}
