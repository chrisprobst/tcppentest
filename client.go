package main

import (
	"flag"
	"fmt"
	"net"
	"os"
	"sync"
	"time"
)

var ip = flag.String("ip", "127.0.0.1", "The ip address of the host")
var port = flag.Int("port", 1337, "The port of the host")
var number = flag.Int("number", 1, "The number of parallel connections")
var id = 0
var mutex sync.Mutex
var longTermHandlers = make(map[int]float64)
var handlers = make(map[int]float64)

func penetrateTCP() {
	handlerId := id
	id++

	mutex.Lock()
	handlers[handlerId] = 0
	longTermHandlers[handlerId] = 0
	mutex.Unlock()

	conn, err := net.Dial("tcp", fmt.Sprintf("%s:%d", *ip, *port))
	if err != nil {
		fmt.Printf("Connection refused at %d\n", handlerId)
		os.Exit(1)
	}

	// Init buffer with crap
	buf := make([]byte, 1024)
	for i := 0; i < len(buf); i++ {
		buf[i%len(buf)] = byte(i)
	}

	// Push unlimited
	initTimeStamp := time.Now()
	timeStamp := initTimeStamp
	written := 0
	longTermWritten := 0

	for {
		// Write next buffer
		n, err := conn.Write(buf)
		if err != nil {
			fmt.Printf("Write failed at %d\n", handlerId)
			os.Exit(1)
		}

		// Update vals
		written += n
		longTermWritten += n
		now := time.Now()
		duration := now.Sub(timeStamp).Seconds()
		longTermDuration := now.Sub(initTimeStamp).Seconds()

		// Check if time has passed
		if duration > 1.0 {

			// Compute the throughput
			mbPerSec := float64(written) / duration / 1024.0 / 1024.0
			longTermMbPerSec := float64(longTermWritten) / longTermDuration / 1024.0 / 1024.0

			// Update map
			mutex.Lock()
			// Update long term
			handlers[handlerId] = mbPerSec
			longTermHandlers[handlerId] = longTermMbPerSec
			mutex.Unlock()

			// Reset vals
			timeStamp = now
			written = 0
		}
	}
}

func main() {
	// Start all handlers
	flag.Parse()
	for i := 0; i < *number; i++ {
		go penetrateTCP()
	}
	fmt.Println("Started all handlers...")

	// Watchout for all rates
	for {
		time.Sleep(time.Second)

		// Create copy of statistics
		mutex.Lock()
		rates := make(map[int]float64)
		for k, v := range handlers {
			rates[k] = v
		}
		mutex.Unlock()

		sum := 0.0
		for i := 0; i < len(rates); i++ {
			k, v := i, rates[i]
			sum += v
			fmt.Printf("%d runs at %f mb/sec\n", k, v)
		}
		average := sum / float64(len(rates))

		fmt.Printf("Average rate: %f mb/sec\n", average)
		fmt.Printf("Sum rate: %f mb/sec\n", sum)
		fmt.Println()
	}
}
